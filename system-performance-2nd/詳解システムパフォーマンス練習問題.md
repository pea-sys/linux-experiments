## メソドロジ

- 1. パフォーマンスの基本用語についての以下の問いに答えなさい

  - IOPS とは何か  
    (答)秒あたりの入出力回数

  * 使用率とは何か  
    (答)リソースがどの程度の割合使用されているかを表した指標
  * 飽和とは何か  
    (答)リソースで即時処理できずにキューイングされた処理
  * レイテンシとは何か  
    (答)目的の処理が実行されるまでの時間
  * マイクロベンチマーキングとは何か  
    (答)特定処理の処理速度を測定する手段

- 2. あなたの環境で使うメソドロジを５つ選びなさい。実践する順序で並べ、個々のメソドロジを選んだ理由を説明しなさい
  - 1. 問題の記述  
       理由)  
       スタンドアローンの組み込みソフトを提供しているため、リモートでのログ等の確認が出来ない。  
       まずは、電話での状況確認になる。
  - 2. 科学的メソッド  
       理由)  
       電話超しの問診で特定できない場合は、ログを送ってもらう。  
       ログから遅くなっている箇所はある程度絞れるのと、リソースの状況もある程度掴めるようになるので仮説が立てられる。
  - 3. USE メソッド  
       理由)  
        これまでの経験に基づいた分析で原因が分からなかった場合は、
       手続きに沿った定型の診断を行う。USE メソッドは手早く出来る。
  - 4. ドリルダウン分析  
       理由)  
       定型の簡易診断で原因が掴めない場合は、高次から掘り下げを繰り返し、原因特定を行う
  - 5. パフォーマンスマントラ  
       理由)  
        原因が特定できたらパフォーマンスマントラに沿って対策を検討・実施する

* 3. 唯一のパフォーマンス指標として平均レイテンシを使ったときの問題点を簡潔に説明しなさい、99 パーセンタイルを含めれば、その問題は解決できるか  
     解答)  
     問題点は統計値として平均を採用している点。パフォーマンスにばらつきがある場合は、悪い時のパフォーマンスは平均によりほとんど隠される可能性が高い。  
     また、99 パーセントタイルは単峰分布を対象としたものであるが、多くの場合、システムパフォーマンスは 2 峰以上の分布であるため、表現として適していない場合がある。

## オペレーティングシステム

- 1. OS 用語について以下の問いに応えなさい
  - プロセス、スレッド、タスクの違いは何か
    解答)  
    プロセスはプログラムの実行環境。スレッドはスケジューリング可能な実行コンテキストであり、プロセスは複数のスレッドを持ちうる。タスクは処理の実行単位である。
  - モードスイッチとコンテキストスイッチとは何か  
    解答)  
    モードスイッチはカーネルモードとユーザーモードを切り替えるスイッチ。コンテキストスイッチはスレッドやプロセスを切り替えるスイッチ
  - ページングとスワッピングの違いは何か  
    解答)  
    ページングは仮想メモリのデータを物理メモリに読み書きすること。スワッピングはメモリとディスクのデータを交換し、実メモリより多くのデータを透過的に扱う。
  - I/O バウンドワークロードと CPU バウンドワークロードの違いは何か  
    解答)  
    I/O バウンドワークロードは CPU にほとんど負荷をかけないが、CPU バウンドワークロードは CPU への負担が大きい。
- 2. コンセプトについて以下の問いに答えなさい

  - カーネルの役割を説明しなさい  
    解答)
    カーネルは OS の中核となる機能を有する。
  - システムコールの役割を説明しなさい  
    解答)  
    カーネルモードで動く処理のインターフェース提供する
  - VFS の役割と I/O スタック内での位置を説明しなさい  
    解答)  
    ファイルシステムを抽象化する役割で、ファイルシステムの上層に位置する

- 3. 難易度の高い以下の問いに答えなさい

  - スレッドが CPU を手放す理由を列挙しなさい  
    解答)
    - 割込み処理を可能にするため
    * 消費電力の浪費を防ぐため
    * 非同期処理を可能にするため
    * モードスイッチを可能にするため
  - 仮想メモリとデマンドページングの利点を説明しなさい  
    解答)  
    仮想メモリにより実メモリより多くのデータを取り扱える  
    仮想メモリへの読み書きは時間が掛かるため、デマンドページングにより実際に必要になったタイミングで最小限のページのみを実メモリにロードして、最小限のコストでデータを読み書き可能とする。

## 可観測性ツール

- 1. 静的パフォーマンスツールの例を挙げなさい  
     解答)  
     df, dmesg, sysctl
- 2. プロファイリングとは何か  
     解答)  
     分析手法。測定し、問題点を検出・特定するために使用する。
- 3. プロファイラが 100Hz ではなく 99Hz を使うのはなぜか  
     解答)  
     ターゲットのサンプリングと歩調が合わないようにするため。  
     計測値がぶれやすくなる。
- 4. トレーシングとは何か  
     解答)  
     処理やデータの流れを追跡すること
- 5. 静的インストルメンテーションとは何か  
     解答)  
     ハードコードされたトレーシングポイント
- 6. 動的インストルメンテーションが重要な理由を説明しなさい  
     解答)  
     本番稼働しているカーネルから静的インストール面テーションでは取り出せない任意の情報を取り出せる。問題の観察をするための最後の手段として重要。
- 7. トレースポイントと kprobe の違いは何か  
     解答)  
     トレースポイントとは静的インストルメンテーションのイベントソース  
     kprobe は動的インストルメンテーションのイベントソース
- 8. 以下の作業で予想される CPU のオーバーヘッド(低いか普通か高いか)を説明しなさい

  - ディスクの IOPS カウンタ(iostat(1)で見られるもの)  
    解答)  
    オーバーヘッドは低い。カーネルがデフォルトで有効にしているため。
  - トレーシングポイントが kprobe を使ったディスク I/O ごとのトレーシング  
    解答)  
    kretprobe を使用することになるのでオーバーヘッドは低くないが、ディスク I/O のコストと比較すると普通程度と予想。
  - トレーシングポイントが kprobe を使ったコンテキストスイッチごとのトレーシング  
     解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。
  - トレーシングポイントが kprobe を使ったプロセスの起動(execve(2))ごとのトレーシング  
    解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。
  - uprobe を使った libc_malloc()が呼び出しごとのトレーシング  
    解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。

- 9. パフォーマンス分析で PMC に価値がある理由を説明しなさい  
     解答)  
     PMC でのみ得られるプロセッサのプロファイル情報から、CPU の使い方を最適化できる。

- 10. 可観測性ツールが与えられたとき、どうすればそれが使っているインストルメンテーションを明らかにできるか説明しなさい  
      解答)  
      ツールが提供する統計量と一致する情報を提供する標準的なツールを探し出し、ソースコードを辿る。

## アプリケーション

- 1. 用語についての以下の問いに答えなさい

  - キャッシュとは何か  
    解答)  
    1 度アクセスした情報を高速にアクセスできる位置に一時的に保存しておく方法
  - リングバッファとは何か  
    解答)  
    ローテーションでメモリを使用するバッファ  
    メモリサイズが固定なので、メモリ確保のコストがない

  - スピンロックとは何か  
    解答)  
    複数のスレッドやプロセスが共有リソースへのアクセスを制御するために使用する。リソースが他のスレッドやプロセスによって利用可能になるのを待つ代わりに、ロック解除されるまで継続的に試行し続ける。
  - アダプティブミューテックスロックとは何か  
    解答)
    複数のスレッドが共有リソースへのアクセスを制御するために使用する。待機時間が短い場合にはスピンロックのように動作し、長い場合はスレッドをスリープさせて、CPU の無駄遣いを防ぐ。
  - 並行実行と並列処理の違いは何か  
     解答)
    　　並行実行は複数タスクが on-CPU されるとは限らないが、並列処理は複数タスクが on-CPU になる
  - CPU アフィニティとは何か  
    解答)  
    特定のプロセスまたはスレッドが実行される CPU コアを制御する概念。リソース制限やパフォーマンス向上を目的としている。

- 2. コンセプトについての以下の問いに答えなさい

  - 大きな I/O サイズを使うことの一般的な長所・短所は何か  
    解答)  
    長所：I/O サイズが大きくなることで I/O の頻度が減り、CPU の待ち時間が減る。一方で、余計なメモリを確保し、リソースを無駄遣いする場合もある。
  - ロックのハッシュテーブルは何のために使われているか  
    解答)  
    1 個のロックリソースを共有することによるロック競合を回避しつつ、対象リソース毎にロックリソースを用意した場合のロック制御の CPU 負荷の増大化を回避するための使用。

  - コンパイル言語、インタープリタ言語、仮想マシンを使う言語の実行時の一般的なパフォーマンス特性を説明しなさい  
    解答)  
    コンパイル言語は CPU の実行可能なバイナリファイルが生成されるため、パフォーマンスは良い傾向にある。インタープリタ言語はプログラム実行時に動的に機械語に変換するため、パフォーマンスが低い傾向にある。仮想マシンはコンパイルとインタープリタの両方をサポートしている。仮想マシン上で動作するためコンパイルをしたとしても、コンパイル言語よりはパフォーマンスは落ちる。

  - ガベージコレクションの役割とパフォーマンスに与える影響について答えなさい  
    解答)  
    不要になったマネージドオブジェクトの使用メモリを自動的に解法し、大部分のメモリ管理を自動管理する。ガベージコレクションは比較的コストの大きい処理であるため、CPU 負荷が高く、他の処理を遅くする可能性がある。

* 3. アプリケーションを選び、以下の基本的な問いに答えなさい  
     選択したアプリケーション:zopfli  
     https://github.com/google/zopfli/blob/master/README.zopflipng

  - そのアプリケーションの役割は何か  
    解答)  
    png の圧縮

  - そのアプリケーションは別々のオペレーションとして何をしているか  
    解答)  
    png のロード

  - そのアプリケーションはユーザーモードとカーネルモードのどちらで実行されるか  
    解答)  
    ユーザーモード

  - そのアプリケーションはどのように構成されているか。パフォーマンスに関して、どのようなオプションがあるか  
    解答)  
    イテレーションを指定して、イテレーション回数のを枝切りが可能

  - そのアプリケーションはどのようなパフォーマンス指標を提供しているか  
    解答)  
    圧縮率

  - そのアプリケーションはどのようなログを作っているか。ログにパフォーマンス指標は含まれているか  
    解答)  
    ログはなく、標準出力のみ。

  - そのアプリケーションの最新バージョンはパフォーマンス問題を解決しているか  
    解答)  
    はい。ただし、もうメンテナンスは数年おこなわれていない。

  - そのアプリケーションに既知のパフォーマンスバグはあるか  
    解答)  
    圧縮率が増えた場合に、レポートの圧縮率がアンダーフローを起こすバグがある
  - そのアプリケーションにコミュニティはあるか。パフォーマンスコミュニティはどうか  
    解答)  
    Github がコミュニティになっている、パフォーマンスコミュニティの存在は認識していない。

  - そのアプリケーションについての本はあるか。パフォーマンスについての本はどうか  
    解答)  
    本はない

  - そのアプリケーションのパフォーマンスについて有名なエキスパートはいるか。いるなら誰か  
    解答)  
    いない

* 4. 負荷のかかっているアプリケーションを選び、以下の作業をしなさい（多くのものは動的トレーシングを必要とする)  
     選択したアプリケーション:zopfli

  - 計測を行う前に、そのアプリケーションが CPU バウンドか I/O バウンドか予想しなさい。また、その理由を説明しなさい。  
    解答)  
    CPU バウンド。zopfli でサポートしている deflate 圧縮は通常 CPU コストの高さから試行回数を 1 回で打ち切るようにしているが、zopfli は圧縮試行を何回も行うため。

  - CPU バウンドか I/O バウンドかを可観測性ツールで明らかにしなさい  
    解答)  
    top コマンドで確認したところ、zopflipng プロセスの 動作中の大部分の時間において CPU 使用率が 100%になっている

    ```
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    590 masami    20   0   10288   7764   3624 R  99.7   0.2   0:13.43 zopflipng
    441 root      20   0  967556  84808  26316 S   0.3   2.1   0:30.21 python3.10
    447 root      20   0   43180  37628  10156 S   0.3   0.9   0:12.75 python3
    588 masami    20   0    7796   3704   3108 R   0.3   0.1   0:00.10 top
    ・・・
    ```

    perf コマンドで確認すると、1.90 insn per cycle なので、2core をほとんど CPU 命令に使い切っている状況

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user [255]> sudo perf stat -a -- sleep 10
    [sudo] password for masami:

    Performance counter stats for 'system wide':

          40020.11 msec cpu-clock                 #    4.000 CPUs utilized
               683      context-switches          #   17.066 /sec
                14      cpu-migrations            #    0.350 /sec
              3960      page-faults               #   98.950 /sec
       16216576252      cycles                    #    0.405 GHz
       30786259882      instructions              #    1.90  insn per cycle
        7054228214      branches                  #  176.267 M/sec
         169069741      branch-misses             #    2.40% of all branches

      10.004642769 seconds time elapsed
    ```

  - そのアプリケーションの CPU フレームグラフを作りなさい。この課題では、シンボルとスタックトレースの修復が必要になる場合がある。もっともホットな CPU コードパスは何か  
     解答)  
     プリインストールされている zopfli 実行中のフレームグラフを作ったところ、シンボルが Unknown で追跡が難しい状況

    ```sh
    git clone https://github.com/brendangregg/FlameGraph
    cd FlameGraph
    perf record -F 99 -a -g -- sleep 60
    perf script | ./stackcollapse-perf.pl > out.perf-folded
    ./flamegraph.pl out.perf-folded > perf-kernel.svg
    ```

    ![1](https://github.com/pea-sys/linux-experiments/assets/49807271/97a64941-885b-4196-9442-b241dc07fd64)  
    ネイティブなプログラムのシンボルを追跡するためには再コンパイルが必要？
    次にあるように、Zopfli のコンパイルは難しい状況。
    https://github.com/google/zopfli/issues/143  
    代わりに linux コマンドでも見てみようと思い、カーネルヘッダー をコンパイルしたが、メモリアクセス違反でコンパイルが中断(6 回延べ 15 時間を消費)し、作業中止  
    WSL のリポジトリに Issue は立てておいた。

  - そのアプリケーションの off-CPU フレームグラフを作りなさい。要求の処理中にブロックする時間が最も長いイベントは何か(アイドルスタックは無視する)  
    解答)  
    上記の通り、カーネルヘッダーのコンパイルが出来ないため、bcc ツールに含まれる offcputime が実行不可。スキップします。

  * 実行する I/O のサイズ(例えば、ファイルシステムの読み書き、ネットワークの送受信)の特性を説明しなさい  
    解答)  
    サイズが大きな I/O は時間が掛かるのでレイテンシに影響を与える可能性がある。サイズが小さい I/O の場合、頻繁にシステムコールを使用し、個々の処理のターンアラウンドタイムが増えている可能性がある。適切なバッファサイズを確保し、最適な I/O サイズと頻度に調整することが望ましい。

  * そのアプリケーションはキャッシュを持っているか。あるなら、サイズとヒット率を明らかにしなさい  
     解答)  
    　キャッシュヒット率は 78%

    ```
      masami@DESKTOP-L18OTEK /m/c/U/user> perf stat -e cycles,instructions,cache-references,cache-misses zopfli "/mnt/c/Users/
      user/OneDrive/デスクトップ/1.png"

      Performance counter stats for 'zopfli /mnt/c/Users/user/OneDrive/デスクトップ/1.png':

              395174418      cycles:u
              793660521      instructions:u            #    2.01  insn per cycle
                4171569      cache-references:u
                  945894      cache-misses:u            #   22.675 % of all cache refs

            0.274801520 seconds time elapsed

            0.242133000 seconds user
            0.010088000 seconds sys
    ```

    特定アプリで使用しているキャッシュサイズの確認方法は不明  
    WSL で利用できるキャッシュサイズは次の通り

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user> vmstat -s | grep "cache"
       374344 K swap cache
    ```

  * そのアプリケーションを実行するオペレーションのレイテンシ(応答時間)を計測しなさい。平均、最小値、最大値、全体の分布を示しなさい  
    解答)  
    測定結果

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user> time zopfli --i100 "/mnt/c/Users/user/OneDrive/デスクトップ/globe-scene-fish-bowl-pngcrush.png"
    ________________________________________________________
    Executed in    5.05 secs    fish           external
    Executed in    5.50 secs    fish           external
    Executed in    4.98 secs    fish           external
    Executed in    4.99 secs    fish           external
    Executed in    5.15 secs    fish           external
    Executed in    5.27 secs    fish           external
    Executed in    8.61 secs    fish           external
    Executed in    4.91 secs    fish           external
    Executed in    4.82 secs    fish           external
    Executed in    5.10 secs    fish           external
    ```

    平均 5.475secs 最大値 8.61secs 最小値 4.82secs 分散 1.279

    ![2](https://github.com/pea-sys/linux-experiments/assets/49807271/08445fd0-8472-44c1-a84e-8718e12dad90)

  * オペレーションのドリルダウン分析を行い、レイテンシの主要部がどこに発生しているかを解析しなさい  
    解答)  
    zopflipng を対象とする

    - CPU バウンドか I/O バウンドか  
      →CPU バウンド
    - どの処理に時間が掛かっているか  
      → 今のところコンパイル出来ないため関数レベルでは不明

  * そのアプリケーションのワークロード特性を明らかにしなさい(特に誰がと何を)  
     解答)
    - zopflipng  
      諸事情により zopflipng はコンパイルが困難なので関数情報は得られないが、シングルスレッドで動作している圧縮アルゴリズムの計算がボトルネックになっていることが明らかである。  
      なので、圧縮アルゴリズムのマルチスレッド化や、より計算能力の高い CPU を使用することで  
      パフォーマンスの改善が見込まれる。
      次の通り、並列動作はしない

```
masami@DESKTOP-L18OTEK /m/c/U/user> mpstat -P ALL 1
Linux 5.15.90.1-microsoft-standard-WSL2 (DESKTOP-L18OTEK)       10/08/23        _x86_64_        (4 CPU)
16:35:02     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
16:35:03     all   24.94    0.00    0.00    0.00    0.00    0.25    0.00    0.00    0.00   74.81
16:35:03       0    0.00    0.00    0.00    0.00    0.00    0.99    0.00    0.00    0.00   99.01
16:35:03       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
16:35:03       2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
16:35:03       3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

16:35:54     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
16:35:55     all   25.06    0.00    0.25    0.00    0.00    0.00    0.00    0.00    0.00   74.69
16:35:55       0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
16:35:55       1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
16:35:55       2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
16:35:55       3    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00
```

CPU はユーザーモードでの処理に多くの時間を割いている

```
masami@DESKTOP-L18OTEK /m/c/U/user> mpstat -P ALL 1
Linux 5.15.90.1-microsoft-standard-WSL2 (DESKTOP-L18OTEK)       10/08/23        _x86_64_        (4 CPU)
16:40:21      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:40:22        0       442    1.00    0.00    0.00    0.00    1.00     2  python3.10
16:40:22        0       470    1.00    0.00    0.00    0.00    1.00     3  python3
16:40:22     1000      3125  100.00    0.00    0.00    0.00  100.00     0  zopflipng

16:41:01      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:41:02        0       140    1.00    0.00    0.00    0.00    1.00     2  snapd
16:41:02     1000      3125  100.00    0.00    0.00    0.00  100.00     0  zopflipng
```

分岐予測ミスは少なく、スイッチの回数も少ない。単純に計算処理に時間が掛かっている

```
masami@DESKTOP-L18OTEK /m/c/U/user [255]> sudo perf stat -a -- sleep 20
[sudo] password for masami:

 Performance counter stats for 'system wide':

          80036.55 msec cpu-clock                 #    4.000 CPUs utilized
              1282      context-switches          #   16.018 /sec
                24      cpu-migrations            #    0.300 /sec
               828      page-faults               #   10.345 /sec
       21211226527      cycles                    #    0.265 GHz
       42189881874      instructions              #    1.99  insn per cycle
        9457279816      branches                  #  118.162 M/sec
         169995360      branch-misses             #    1.80% of all branches
```

- 静的パフォーマンスチューニングチェックリストをすべてチェックしなさい  
  解答)

  - バージョン不明(多分 1.0.3)  
    以下にある通り、バージョンの確認手段が提供されていない  
    https://github.com/google/zopfli/pull/139

  * アプリケーションの既知のパフォーマンス障害は何か  
    巨大な画像ファイルを圧縮しようとすると、メモリ不足になる

  * アプリケーションはどのように構成されているか  
    zopfli_bin.c がエントリポイントとなり、defalte.c 経由で lz77 圧縮処理を行い、gzip_container でパッケージングを行っている。

  * アプリケーションはオブジェクトのキャッシュを使用しているか、サイズはどのくらいか  
    ZopfliInitCache オブジェクトを使用している。サイズは入力するファイルサイズに応じて確保している。
  * アプリケーションは特別なモードで実行されているか  
    されていない

  * アプリケーションはどのシステムライブラリを使用しているか
    - 標準ライブラリ
    - 標準入出力ライブラリ
  * アプリケーションはどのメモリアロケータを使っているか  
    malloc
  * アプリケーションはヒープのためにラージページを使うように構成されているか  
    構成されていない
  * アプリケーションはコンパイルされているか。コンパイラーのバージョンはいくつか。コンパイラオプションと最適化はどうなっているか  
    gcc で最適化オプション O3 を使用してコンパイルしている
  * ネイティブコードに高度な命令(intel SSE/SIMD ベクトル命令)は含まれていないか  
    CPU 固有の命令は含まれていない
  * アプリケーションが縮退モードで動作していないか  
    縮退モードは存在しない
  * CPU, メモリ,ファイルシステム,ディスク,ネットワークの利用にシステムから設定された制限、リソースコントロールはないか  
    OS の制限は存在するが、アプリ固有の設定はない。

- そのアプリケーションは並列実行されるか。同期プリミティブの使われ方を調べなさい  
  解答)  
  mpstat で確認した結果、並列実行されていない。よって同期プリミティブも使われていない。

- 5. (高度)複数のスレッド状態分析欄を持ち、それぞれで使った時間を表示する tsastat(8)という Linux 用のツールを開発しなさい、このツールは、pidstat(1)と同じように動作し、変化の過程を出力できるものとする  
     解答)

## CPU

- 1. CPU の用語について以下の問いに答えなさい

  - プロセスとプロセッサの違いは何か  
    解答)

  - ハードウェアスレッドとは何か  
    解答)

  - ランキューとは何か  
    解答)

  - ユーザー時間とカーネル時間の違いは何か  
    解答)

* 2. コンセプトについて以下の問いに答えなさい

  - CPU の使用率と飽和を説明しなさい  
    解答)

  - 命令パイプラインが CPU の使用率をどのようにして上げるか説明し
    なさい  
    解答)

  - プロセッサ命令幅が CPU の使用率をどのようにして上げるか説明しなさい  
    解答)

  - マルチプロセス、マルチスレッディングモデルの利点を説明しなさい  
    解答)

* 3. 以下の少し難しい問いに答えなさい
  - システム CPU が能力以上に実行可能な処理を抱えているときに何が起きるか、アプリケーションのパフォーマンスに対する影響を含めて説明しなさい
  * 実行すべき実行可能な処理がないとき、CPU はなにをするか
  * CPU のパフォーマンスの問題かもしれないものの処理をゆだねられたときに、調査の初期の段階で使う 2 種類のメソドロジを挙げ、その理由を説明しなさい。
* 4. あなたの環境のために次の作業をしなさい
  - CPU リソースのための USE メソッドチェックリスト。個々の指標の取得方法(例えば、度のコマンドを実行するか)と結果の解釈方法も入れること。追加のソフトウェア製品をインストールしたり使ったりする前に、OS が提供する既存の可観測性ツールを使うようにしなさい。
  * CPU リソースのワークロードの特性の把握チェックリスト。個々の指標の取得方法を入れること。まず OS が提供する既存の可観測性ツールを使うようにしなさい。
* 5. 以下の作業をしなさい。
  - ディスク/ロックの大きな負荷がなく、負荷が安定している以下のシステムのロードアベレージを計算しなさい。
    - システムは 64 個の CPU を搭載している
    - システム全体の CPU 使用率は 50%である
    - システム全体での CPU の飽和(実行可能でキューイングされたスレッド数の平均で計測する)は 2.0 になっている
  * アプリケーションを選び、そのユーザーレベル CPU 使用状況をプロファイリングしなさい。どのコードパスっがもっとも CPU を消費しているかを示しなさい。
* 6. (オプション、高度)iostat(1)と同様の表示(パスのリスト、書く方向のスループット、使用率の欄が含まれるようにする)で、物理バスやインターコネクトの使用率を表示するツール、bustop(1)を開発しなさい。可能なら飽和度とエラー指標を入れない、PMC を使うことが必要になるだろう。
