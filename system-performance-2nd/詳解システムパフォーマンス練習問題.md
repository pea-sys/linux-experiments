## メソドロジ

- 1. パフォーマンスの基本用語についての以下の問いに答えなさい

  - IOPS とは何か  
    (答)秒あたりの入出力回数

  * 使用率とは何か  
    (答)リソースがどの程度の割合使用されているかを表した指標
  * 飽和とは何か  
    (答)リソースで即時処理できずにキューイングされた処理
  * レイテンシとは何か  
    (答)目的の処理が実行されるまでの時間
  * マイクロベンチマーキングとは何か  
    (答)特定処理の処理速度を測定する手段

- 2. あなたの環境で使うメソドロジを５つ選びなさい。実践する順序で並べ、個々のメソドロジを選んだ理由を説明しなさい
  - 1. 問題の記述  
       理由)  
       スタンドアローンの組み込みソフトを提供しているため、リモートでのログ等の確認が出来ない。  
       まずは、電話での状況確認になる。
  - 2. 科学的メソッド  
       理由)  
       電話超しの問診で特定できない場合は、ログを送ってもらう。  
       ログから遅くなっている箇所はある程度絞れるのと、リソースの状況もある程度掴めるようになるので仮説が立てられる。
  - 3. USE メソッド  
       理由)  
        これまでの経験に基づいた分析で原因が分からなかった場合は、
       手続きに沿った定型の診断を行う。USE メソッドは手早く出来る。
  - 4. ドリルダウン分析  
       理由)  
       定型の簡易診断で原因が掴めない場合は、高次から掘り下げを繰り返し、原因特定を行う
  - 5. パフォーマンスマントラ  
       理由)  
        原因が特定できたらパフォーマンスマントラに沿って対策を検討・実施する

* 3. 唯一のパフォーマンス指標として平均レイテンシを使ったときの問題点を簡潔に説明しなさい、99 パーセンタイルを含めれば、その問題は解決できるか  
     解答)  
     問題点は統計値として平均を採用している点。パフォーマンスにばらつきがある場合は、悪い時のパフォーマンスは平均によりほとんど隠される可能性が高い。  
     また、99 パーセントタイルは単峰分布を対象としたものであるが、多くの場合、システムパフォーマンスは 2 峰以上の分布であるため、表現として適していない場合がある。

## オペレーティングシステム

- 1. OS 用語について以下の問いに応えなさい
  - プロセス、スレッド、タスクの違いは何か
    解答)  
    プロセスはプログラムの実行環境。スレッドはスケジューリング可能な実行コンテキストであり、プロセスは複数のスレッドを持ちうる。タスクは処理の実行単位である。
  - モードスイッチとコンテキストスイッチとは何か  
    解答)  
    モードスイッチはカーネルモードとユーザーモードを切り替えるスイッチ。コンテキストスイッチはスレッドやプロセスを切り替えるスイッチ
  - ページングとスワッピングの違いは何か  
    解答)  
    ページングは仮想メモリのデータを物理メモリに読み書きすること。スワッピングはメモリとディスクのデータを交換し、実メモリより多くのデータを透過的に扱う。
  - I/O バウンドワークロードと CPU バウンドワークロードの違いは何か  
    解答)  
    I/O バウンドワークロードは CPU にほとんど負荷をかけないが、CPU バウンドワークロードは CPU への負担が大きい。
- 2. コンセプトについて以下の問いに答えなさい

  - カーネルの役割を説明しなさい  
    解答)
    カーネルは OS の中核となる機能を有する。
  - システムコールの役割を説明しなさい  
    解答)  
    カーネルモードで動く処理のインターフェース提供する
  - VFS の役割と I/O スタック内での位置を説明しなさい  
    解答)  
    ファイルシステムを抽象化する役割で、ファイルシステムの上層に位置する

- 3. 難易度の高い以下の問いに答えなさい

  - スレッドが CPU を手放す理由を列挙しなさい  
    解答)
    - 割込み処理を可能にするため
    * 消費電力の浪費を防ぐため
    * 非同期処理を可能にするため
    * モードスイッチを可能にするため
  - 仮想メモリとデマンドページングの利点を説明しなさい  
    解答)  
    仮想メモリにより実メモリより多くのデータを取り扱える  
    仮想メモリへの読み書きは時間が掛かるため、デマンドページングにより実際に必要になったタイミングで最小限のページのみを実メモリにロードして、最小限のコストでデータを読み書き可能とする。

## 可観測性ツール

- 1. 静的パフォーマンスツールの例を挙げなさい  
     解答)  
     df, dmesg, sysctl
- 2. プロファイリングとは何か  
     解答)  
     分析手法。測定し、問題点を検出・特定するために使用する。
- 3. プロファイラが 100Hz ではなく 99Hz を使うのはなぜか  
     解答)  
     ターゲットのサンプリングと歩調が合わないようにするため。  
     計測値がぶれやすくなる。
- 4. トレーシングとは何か  
     解答)  
     処理やデータの流れを追跡すること
- 5. 静的インストルメンテーションとは何か  
     解答)  
     ハードコードされたトレーシングポイント
- 6. 動的インストルメンテーションが重要な理由を説明しなさい  
     解答)  
     本番稼働しているカーネルから静的インストール面テーションでは取り出せない任意の情報を取り出せる。問題の観察をするための最後の手段として重要。
- 7. トレースポイントと kprobe の違いは何か  
     解答)  
     トレースポイントとは静的インストルメンテーションのイベントソース  
     kprobe は動的インストルメンテーションのイベントソース
- 8. 以下の作業で予想される CPU のオーバーヘッド(低いか普通か高いか)を説明しなさい

  - ディスクの IOPS カウンタ(iostat(1)で見られるもの)  
    解答)  
    オーバーヘッドは低い。カーネルがデフォルトで有効にしているため。
  - トレーシングポイントが kprobe を使ったディスク I/O ごとのトレーシング  
    解答)  
    kretprobe を使用することになるのでオーバーヘッドは低くないが、ディスク I/O のコストと比較すると普通程度と予想。
  - トレーシングポイントが kprobe を使ったコンテキストスイッチごとのトレーシング  
     解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。
  - トレーシングポイントが kprobe を使ったプロセスの起動(execve(2))ごとのトレーシング  
    解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。
  - uprobe を使った libc_malloc()が呼び出しごとのトレーシング  
    解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。

- 9. パフォーマンス分析で PMC に価値がある理由を説明しなさい  
     解答)  
     PMC でのみ得られるプロセッサのプロファイル情報から、CPU の使い方を最適化できる。

- 10. 可観測性ツールが与えられたとき、どうすればそれが使っているインストルメンテーションを明らかにできるか説明しなさい  
      解答)  
      ツールが提供する統計量と一致する情報を提供する標準的なツールを探し出し、ソースコードを辿る。

## アプリケーション

- 1. 用語についての以下の問いに答えなさい

  - キャッシュとは何か  
    解答)  
    1 度アクセスした情報を高速にアクセスできる位置に一時的に保存しておく方法
  - リングバッファとは何か  
    解答)  
    ローテーションでメモリを使用するバッファ  
    メモリサイズが固定なので、メモリ確保のコストがない

  - スピンロックとは何か  
    解答)  
    複数のスレッドやプロセスが共有リソースへのアクセスを制御するために使用する。リソースが他のスレッドやプロセスによって利用可能になるのを待つ代わりに、ロック解除されるまで継続的に試行し続ける。
  - アダプティブミューテックスロックとは何か  
    解答)
    複数のスレッドが共有リソースへのアクセスを制御するために使用する。待機時間が短い場合にはスピンロックのように動作し、長い場合はスレッドをスリープさせて、CPU の無駄遣いを防ぐ。
  - 並行実行と並列処理の違いは何か  
     解答)
    　　並行実行は複数タスクが on-CPU されるとは限らないが、並列処理は複数タスクが on-CPU になる
  - CPU アフィニティとは何か  
    解答)  
    特定のプロセスまたはスレッドが実行される CPU コアを制御する概念。リソース制限やパフォーマンス向上を目的としている。

- 2. コンセプトについての以下の問いに答えなさい

  - 大きな I/O サイズを使うことの一般的な長所・短所は何か  
    解答)  
    長所：I/O サイズが大きくなることで I/O の頻度が減り、CPU の待ち時間が減る。一方で、余計なメモリを確保し、リソースを無駄遣いする場合もある。
  - ロックのハッシュテーブルは何のために使われているか  
    解答)  
    1 個のロックリソースを共有することによるロック競合を回避しつつ、対象リソース毎にロックリソースを用意した場合のロック制御の CPU 負荷の増大化を回避するための使用。

  - コンパイル言語、インタープリタ言語、仮想マシンを使う言語の実行時の一般的なパフォーマンス特性を説明しなさい  
    解答)  
    コンパイル言語は CPU の実行可能なバイナリファイルが生成されるため、パフォーマンスは良い傾向にある。インタープリタ言語はプログラム実行時に動的に機械語に変換するため、パフォーマンスが低い傾向にある。仮想マシンはコンパイルとインタープリタの両方をサポートしている。仮想マシン上で動作するためコンパイルをしたとしても、コンパイル言語よりはパフォーマンスは落ちる。

  - ガベージコレクションの役割とパフォーマンスに与える影響について答えなさい  
    解答)  
    不要になったマネージドオブジェクトの使用メモリを自動的に解法し、大部分のメモリ管理を自動管理する。ガベージコレクションは比較的コストの大きい処理であるため、CPU 負荷が高く、他の処理を遅くする可能性がある。

* 3. アプリケーションを選び、以下の基本的な問いに答えなさい  
     選択したアプリケーション:zopfli  
     https://github.com/google/zopfli/blob/master/README.zopflipng

  - そのアプリケーションの役割は何か  
    解答)  
    png の圧縮

  - そのアプリケーションは別々のオペレーションとして何をしているか  
    解答)  
    png のロード

  - そのアプリケーションはユーザーモードとカーネルモードのどちらで実行されるか  
    解答)  
    ユーザーモード

  - そのアプリケーションはどのように構成されているか。パフォーマンスに関して、どのようなオプションがあるか  
    解答)  
    イテレーションを指定して、イテレーション回数のを枝切りが可能

  - そのアプリケーションはどのようなパフォーマンス指標を提供しているか  
    解答)  
    圧縮率

  - そのアプリケーションはどのようなログを作っているか。ログにパフォーマンス指標は含まれているか  
    解答)  
    ログはなく、標準出力のみ。

  - そのアプリケーションの最新バージョンはパフォーマンス問題を解決しているか  
    解答)  
    はい。ただし、もうメンテナンスは数年おこなわれていない。

  - そのアプリケーションに既知のパフォーマンスバグはあるか  
    解答)  
    圧縮率が増えた場合に、レポートの圧縮率がアンダーフローを起こすバグがある
  - そのアプリケーションにコミュニティはあるか。パフォーマンスコミュニティはどうか  
    解答)  
    Github がコミュニティになっている、パフォーマンスコミュニティの存在は認識していない。

  - そのアプリケーションについての本はあるか。パフォーマンスについての本はどうか  
    解答)  
    本はない

  - そのアプリケーションのパフォーマンスについて有名なエキスパートはいるか。いるなら誰か  
    解答)  
    いない

* 4. 負荷のかかっているアプリケーションを選び、以下の作業をしなさい（多くのものは動的トレーシングを必要とする)  
     選択したアプリケーション:zopfli

  - 計測を行う前に、そのアプリケーションが CPU バウンドか I/O バウンドか予想しなさい。また、その理由を説明しなさい。  
    解答)  
    CPU バウンド。zopfli でサポートしている deflate 圧縮は通常 CPU コストの高さから試行回数を 1 回で打ち切るようにしているが、zopfli は圧縮試行を何回も行うため。

  - CPU バウンドか I/O バウンドかを可観測性ツールで明らかにしなさい  
    解答)  
    top コマンドで確認したところ、zopflipng プロセスの 動作中の大部分の時間において CPU 使用率が 100%になっている

    ```
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    590 masami    20   0   10288   7764   3624 R  99.7   0.2   0:13.43 zopflipng
    441 root      20   0  967556  84808  26316 S   0.3   2.1   0:30.21 python3.10
    447 root      20   0   43180  37628  10156 S   0.3   0.9   0:12.75 python3
    588 masami    20   0    7796   3704   3108 R   0.3   0.1   0:00.10 top
    ・・・
    ```

    perf コマンドで確認すると、1.90 insn per cycle なので、2core をほとんど CPU 命令に使い切っている状況

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user [255]> sudo perf stat -a -- sleep 10
    [sudo] password for masami:

    Performance counter stats for 'system wide':

          40020.11 msec cpu-clock                 #    4.000 CPUs utilized
               683      context-switches          #   17.066 /sec
                14      cpu-migrations            #    0.350 /sec
              3960      page-faults               #   98.950 /sec
       16216576252      cycles                    #    0.405 GHz
       30786259882      instructions              #    1.90  insn per cycle
        7054228214      branches                  #  176.267 M/sec
         169069741      branch-misses             #    2.40% of all branches

      10.004642769 seconds time elapsed
    ```

  - そのアプリケーションの CPU フレームグラフを作りなさい。この課題では、シンボルとスタックトレースの修復が必要になる場合がある。もっともホットな CPU コードパスは何か  
     解答)  
     プリインストールされている zopfli 実行中のフレームグラフを作ったところ、シンボルが Unknown で追跡が難しい状況

    ```sh
    git clone https://github.com/brendangregg/FlameGraph
    cd FlameGraph
    perf record -F 99 -a -g -- sleep 60
    perf script | ./stackcollapse-perf.pl > out.perf-folded
    ./flamegraph.pl out.perf-folded > perf-kernel.svg
    ```

    ![1](https://github.com/pea-sys/linux-experiments/assets/49807271/97a64941-885b-4196-9442-b241dc07fd64)  
    ネイティブなプログラムのシンボルを追跡するためには再コンパイルが必要？
    次にあるように、Zopfli のコンパイルは難しい状況。
    https://github.com/google/zopfli/issues/143  
    代わりに linux コマンドでも見てみようと思い、カーネルヘッダー をコンパイルしたが、メモリアクセス違反でコンパイルが中断(6 回延べ 15 時間を消費)し、作業中止  
    WSL のリポジトリに Issue は立てておいた。

  - そのアプリケーションの off-CPU フレームグラフを作りなさい。要求の処理中にブロックする時間が最も長いイベントは何か(アイドルスタックは無視する)  
    解答)  
    上記の通り、カーネルヘッダーのコンパイルが出来ないため、bcc ツールに含まれる offcputime が実行不可。スキップします。

  * 実行する I/O のサイズ(例えば、ファイルシステムの読み書き、ネットワークの送受信)の特性を説明しなさい  
    解答)  
    サイズが大きな I/O は時間が掛かるのでレイテンシに影響を与える可能性がある。サイズが小さい I/O の場合、頻繁にシステムコールを使用し、個々の処理のターンアラウンドタイムが増えている可能性がある。適切なバッファサイズを確保し、最適な I/O サイズと頻度に調整することが望ましい。

  * そのアプリケーションはキャッシュを持っているか。あるなら、サイズとヒット率を明らかにしなさい  
     解答)  
    　キャッシュヒット率は 78%

    ```
      masami@DESKTOP-L18OTEK /m/c/U/user> perf stat -e cycles,instructions,cache-references,cache-misses zopfli "/mnt/c/Users/
      user/OneDrive/デスクトップ/1.png"

      Performance counter stats for 'zopfli /mnt/c/Users/user/OneDrive/デスクトップ/1.png':

              395174418      cycles:u
              793660521      instructions:u            #    2.01  insn per cycle
                4171569      cache-references:u
                  945894      cache-misses:u            #   22.675 % of all cache refs

            0.274801520 seconds time elapsed

            0.242133000 seconds user
            0.010088000 seconds sys
    ```

    特定アプリで使用しているキャッシュサイズの確認方法は不明  
    WSL で利用できるキャッシュサイズは次の通り

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user> vmstat -s | grep "cache"
       374344 K swap cache
    ```

  * そのアプリケーションを実行するオペレーションのレイテンシ(応答時間)を計測しなさい。平均、最小値、最大値、全体の分布を示しなさい  
    解答)  
    測定結果

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user> time zopfli --i100 "/mnt/c/Users/user/OneDrive/デスクトップ/globe-scene-fish-bowl-pngcrush.png"
    ________________________________________________________
    Executed in    5.05 secs    fish           external
    Executed in    5.50 secs    fish           external
    Executed in    4.98 secs    fish           external
    Executed in    4.99 secs    fish           external
    Executed in    5.15 secs    fish           external
    Executed in    5.27 secs    fish           external
    Executed in    8.61 secs    fish           external
    Executed in    4.91 secs    fish           external
    Executed in    4.82 secs    fish           external
    Executed in    5.10 secs    fish           external
    ```

    平均 5.475secs 最大値 8.61secs 最小値 4.82secs 分散 1.279

    ![2](https://github.com/pea-sys/linux-experiments/assets/49807271/08445fd0-8472-44c1-a84e-8718e12dad90)

  * オペレーションのドリルダウン分析を行い、レイテンシの主要部がどこに発生しているかを解析しなさい  
    解答)  
    zopflipng を対象とする

    - CPU バウンドか I/O バウンドか  
      →CPU バウンド
    - どの処理に時間が掛かっているか  
      → 今のところコンパイル出来ないため関数レベルでは不明

  * そのアプリケーションのワークロード特性を明らかにしなさい(特に誰がと何を)  
     解答)
    - zopflipng  
      諸事情により zopflipng はコンパイルが困難なので関数情報は得られないが、シングルスレッドで動作している圧縮アルゴリズムの計算がボトルネックになっていることが明らかである。  
      なので、圧縮アルゴリズムのマルチスレッド化や、より計算能力の高い CPU を使用することで  
      パフォーマンスの改善が見込まれる。
      次の通り、並列動作はしない

```
masami@DESKTOP-L18OTEK /m/c/U/user> mpstat -P ALL 1
Linux 5.15.90.1-microsoft-standard-WSL2 (DESKTOP-L18OTEK)       10/08/23        _x86_64_        (4 CPU)
16:35:02     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
16:35:03     all   24.94    0.00    0.00    0.00    0.00    0.25    0.00    0.00    0.00   74.81
16:35:03       0    0.00    0.00    0.00    0.00    0.00    0.99    0.00    0.00    0.00   99.01
16:35:03       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
16:35:03       2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
16:35:03       3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

16:35:54     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
16:35:55     all   25.06    0.00    0.25    0.00    0.00    0.00    0.00    0.00    0.00   74.69
16:35:55       0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
16:35:55       1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
16:35:55       2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
16:35:55       3    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00
```

CPU はユーザーモードでの処理に多くの時間を割いている

```
masami@DESKTOP-L18OTEK /m/c/U/user> mpstat -P ALL 1
Linux 5.15.90.1-microsoft-standard-WSL2 (DESKTOP-L18OTEK)       10/08/23        _x86_64_        (4 CPU)
16:40:21      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:40:22        0       442    1.00    0.00    0.00    0.00    1.00     2  python3.10
16:40:22        0       470    1.00    0.00    0.00    0.00    1.00     3  python3
16:40:22     1000      3125  100.00    0.00    0.00    0.00  100.00     0  zopflipng

16:41:01      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:41:02        0       140    1.00    0.00    0.00    0.00    1.00     2  snapd
16:41:02     1000      3125  100.00    0.00    0.00    0.00  100.00     0  zopflipng
```

分岐予測ミスは少なく、スイッチの回数も少ない。単純に計算処理に時間が掛かっている

```
masami@DESKTOP-L18OTEK /m/c/U/user [255]> sudo perf stat -a -- sleep 20
[sudo] password for masami:

 Performance counter stats for 'system wide':

          80036.55 msec cpu-clock                 #    4.000 CPUs utilized
              1282      context-switches          #   16.018 /sec
                24      cpu-migrations            #    0.300 /sec
               828      page-faults               #   10.345 /sec
       21211226527      cycles                    #    0.265 GHz
       42189881874      instructions              #    1.99  insn per cycle
        9457279816      branches                  #  118.162 M/sec
         169995360      branch-misses             #    1.80% of all branches
```

- 静的パフォーマンスチューニングチェックリストをすべてチェックしなさい  
  解答)

  - バージョン不明(多分 1.0.3)  
    以下にある通り、バージョンの確認手段が提供されていない  
    https://github.com/google/zopfli/pull/139

  * アプリケーションの既知のパフォーマンス障害は何か  
    巨大な画像ファイルを圧縮しようとすると、メモリ不足になる

  * アプリケーションはどのように構成されているか  
    zopfli_bin.c がエントリポイントとなり、defalte.c 経由で lz77 圧縮処理を行い、gzip_container でパッケージングを行っている。

  * アプリケーションはオブジェクトのキャッシュを使用しているか、サイズはどのくらいか  
    ZopfliInitCache オブジェクトを使用している。サイズは入力するファイルサイズに応じて確保している。
  * アプリケーションは特別なモードで実行されているか  
    されていない

  * アプリケーションはどのシステムライブラリを使用しているか
    - 標準ライブラリ
    - 標準入出力ライブラリ
  * アプリケーションはどのメモリアロケータを使っているか  
    malloc
  * アプリケーションはヒープのためにラージページを使うように構成されているか  
    構成されていない
  * アプリケーションはコンパイルされているか。コンパイラーのバージョンはいくつか。コンパイラオプションと最適化はどうなっているか  
    gcc で最適化オプション O3 を使用してコンパイルしている
  * ネイティブコードに高度な命令(intel SSE/SIMD ベクトル命令)は含まれていないか  
    CPU 固有の命令は含まれていない
  * アプリケーションが縮退モードで動作していないか  
    縮退モードは存在しない
  * CPU, メモリ,ファイルシステム,ディスク,ネットワークの利用にシステムから設定された制限、リソースコントロールはないか  
    OS の制限は存在するが、アプリ固有の設定はない。

- そのアプリケーションは並列実行されるか。同期プリミティブの使われ方を調べなさい  
  解答)  
  mpstat で確認した結果、並列実行されていない。よって同期プリミティブも使われていない。

- 5. (高度)複数のスレッド状態分析欄を持ち、それぞれで使った時間を表示する tsastat(8)という Linux 用のツールを開発しなさい、このツールは、pidstat(1)と同じように動作し、変化の過程を出力できるものとする  
     解答)

## CPU

- 1. CPU の用語について以下の問いに答えなさい

  - プロセスとプロセッサの違いは何か  
    解答)  
    プロセスは論理的な処理単位。プロセッサは物理的な計算機。
  - ハードウェアスレッドとは何か  
    解答)  
    1 つのコア上で複数のスレッドの並列実行をサポートする CPU アーキテクチャ

  - ランキューとは何か  
    解答)  
    CPU が与えられるのを待っている実行可能スレッドのキュー。

  - ユーザー時間とカーネル時間の違いは何か  
    解答)  
    ユーザーモードまたはカーネルモードで CPU 実行した時間。

* 2. コンセプトについて以下の問いに答えなさい

  - CPU の使用率と飽和を説明しなさい  
    解答)  
    使用率は一定時間内に CPU がビジーになっていた時間の割合。  
    飽和は CPU 使用率上限に達した状態。

  - 命令パイプラインが CPU の使用率をどのようにして上げるか説明し
    なさい  
    解答)  
    異なる命令を並列実行することで CPU の使用率を上げる

  - プロセッサ命令幅が CPU の使用率をどのようにして上げるか説明しなさい  
    解答)  
    命令幅の増加することで並列実行できる命令の数が増えて、CPU の使用率が上がる

  - マルチプロセス、マルチスレッディングモデルの利点を説明しなさい  
    解答)  
    マルチプロセスはプロセス別に独立性を維持したまま開発することが出来るので、開発難易度が低い。また、１つのプロセスが強制終了しても他のプロセスに影響を与えにくい。  
    マルチスレッディングモデルは、メモリの消費量が少なく、処理速度も早い傾向にある。

* 3. 以下の少し難しい問いに答えなさい

  - システム CPU が能力以上に実行可能な処理を抱えているときに何が起きるか、アプリケーションのパフォーマンスに対する影響を含めて説明しなさい  
    解答)  
    命令処理がランキューに溜まっている状況となるため、アプリケーションは CPU バウンドのパフォーマンス定価の影響を受けることになる

  * 実行すべき実行可能な処理がないとき、CPU はなにをするか  
    解答)  
    アイドルスレッドにより、CPU は節電モードに入る、

  * CPU のパフォーマンスの問題かもしれないものの処理をゆだねられたときに、調査の初期の段階で使う 2 種類のメソドロジを挙げ、その理由を説明しなさい。  
    解答)  
     USE メソッドにより、すべてのコンポーネントを対象としてボトルネックやエラーを見つける。その後、プロファイリングにより解析対象の具体像を構築する。

* 4. あなたの環境のために次の作業をしなさい

  - CPU リソースのための USE メソッドチェックリスト。個々の指標の取得方法(例えば、どのコマンドを実行するか)と結果の解釈方法も入れること。追加のソフトウェア製品をインストールしたり使ったりする前に、OS が提供する既存の可観測性ツールを使うようにしなさい。  
    解答)
    - 使用率・・・mpstat(linux マシン購入後に実施)
    - 飽和度・・・vmstat の r を見る
    - CPU エラー・・・ECC メモリに対応していないのでチェック不可

  * CPU リソースのワークロードの特性の把握チェックリスト。個々の指標の取得方法を入れること。まず OS が提供する既存の可観測性ツールを使うようにしなさい。  
    解答)

    - ロードアベレージ(使用率+飽和度):htop で load average の項目を見る
    - ユーザー時間とシステム時間の比較:pidstats で%usr と%system の項目を見る
    - システムコールの頻度:dtrace
    - 自発的なコンテキストスイッチの頻度

    ```
    masami@DESKTOP-L18OTEK /m/c/W/system32 [1]> ps
    PID TTY          TIME CMD
    395 pts/0    00:00:10 fish
    952 pts/0    00:00:00 ps
    masami@DESKTOP-L18OTEK /m/c/W/system32> cat /proc/395/status | grep ctxt
    voluntary_ctxt_switches:        15838
    nonvoluntary_ctxt_switches:     61
    ```

    - 割込みの頻度:mpstat の irq

    ```
    masami@DESKTOP-L18OTEK /m/c/W/system32> mpstat -P ALL 1
    Linux 5.15.90.1-microsoft-standard-WSL2 (DESKTOP-L18OTEK)       10/14/23        _x86_64_        (4 CPU)

    18:31:08     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    18:31:09     all    0.50    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.50
    18:31:09       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
    18:31:09       1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
    18:31:09       2    0.99    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.01
    18:31:09       3    0.99    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.01
    ```

* 5. 以下の作業をしなさい。

  - ディスク/ロックの大きな負荷がなく、負荷が安定している以下のシステムのロードアベレージを計算しなさい。

    - システムは 64 個の CPU を搭載している
    - システム全体の CPU 使用率は 50%である
    - システム全体での CPU の飽和(実行可能でキューイングされたスレッド数の平均で計測する)は 2.0 になっている  
      解答)  
      ロードアベレージは実行待ちプロセス数の平均数なので 2
      といいたいところですが、同一プロセスの複数スレッドが同じ CPU に割り当てられることもあるので、分からないような気がします・・・

  * アプリケーションを選び、そのユーザーレベル CPU 使用状況をプロファイリングしなさい。どのコードパスっがもっとも CPU を消費しているかを示しなさい。  
    解答)  
    Linux 実機が手に入ってから実施

* 6. (オプション、高度)iostat(1)と同様の表示(パスのリスト、書く方向のスループット、使用率の欄が含まれるようにする)で、物理バスやインターコネクトの使用率を表示するツール、bustop(1)を開発しなさい。可能なら飽和度とエラー指標を入れない、PMC を使うことが必要になるだろう。

## メモリ

- 1. メモリの用語についての以下の問いに答えなさい

  - メモリのページとは何か  
    解答)  
    OS と CPU が使う単位メモリ
  - 常駐メモリとは何か  
    解答)  
    現在メインメモリにあるメモリ
  - 仮想メモリとは何か  
    解答)  
    実際のメモリではない代替メモリ領域。
  - Linux 用語でページングとスワッピングはどのように異なるか  
    解答)  
    ページングは、メインメモリとスワップデバイスの間でのページ転送  
    スワッピングは、スワップデバイスへの無名ページング

  * 2. コンセプトについての以下の問いに答えなさい

    - デマンドページングの目的は何か  
      解答)  
      CPU に掛かるマッピング作成のオーバーヘッドを先延ばしする

    - メモリの使用率と飽和を説明しなさい  
      解答)  
      使用率はメモリの総量に対するする使用済みメモリの割合  
      飽和はメモリの使用量がメインメモリの総量を越えること

    - MMU と TLB の目的は何か  
      解答)  
      MMU:仮想アドレスからブル地アドレスの変換を行う。CPU キャッシュを参照する際に必要。  
      TLB:仮想アドレスから物理アドレスに変換するキャッシュ

    - ページアウトデーモンの役割は何か  
      解答)  
      ページアウトしたメモリを極力消さずにキャッシュに戻せるようにフリーリストの末尾に追加する

    * OOM キラーの役割は何か  
      解答)  
      プロセスを強制終了してメモリを解放する

  * 3. 以下の少し難しい問いに答えなさい

    - 無名ページングとは何か。ファイルシステムページングよりこの種のページングを分析する方が重要なのは何故か

      解答)  
      無名ページングは、ユーザーアプリの使用するヒープ・スタックを対象としており、ファイルシステムページングと異なり、必ずスワップデバイス、スワップファイルへのデータを必要とし、パフォーマンスを下げるので、なるべく発生しないようにチューニングする必要がある。

    - Linux ベースシステムでフリーメモリを使い切った時に、メモリを解放するためにカーネルが取る手順を説明しなさい  
      解答)

      - 1. ページキャッシュがあればページキャッシュの削除を行う
      - 2. スワッピング可能であれば最近使われてい以内ページをスワッピアプトして、フリーメモリを空ける
      - 3. リーピングによるメモリ解放
      - 4. OOM キラーにより、一部のプロセスを殺し、メモリを返す

    - スラブベースのアロケーションのパフォーマンス上の利点を説明しなさい

      解答)  
      固定サイズのデータ構造を用いることで、アロケーションのオーバーヘッドをかけずに、メモリの高速なリサイクルを可能にしている

  * 4. あなたの環境のために次のモノを作りなさい

    - メモリリソースのための USE メソッドチェックリスト。個々の指標の取得方法と結果の解釈方法。追加のソフトウェア製品をインストールしたり使ったりする前にが OS が提供する既存の可観測性ツールを使うようにしなさい

      解答)

      - 使用率:top -o %MEM で %MEM を見る

        ```
        masami@DESKTOP-L18OTEK /m/c/U/user [1]> top -o %MEM
        top - 09:46:33 up 4 min,  1 user,  load average: 0.11, 0.14, 0.07
        Tasks:  34 total,   1 running,  33 sleeping,   0 stopped,   0 zombie
        %Cpu(s):  0.2 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
        MiB Mem :   3920.8 total,   3130.2 free,    441.5 used,    349.1 buff/cache
        MiB Swap:      0.0 total,      0.0 free,      0.0 used.   3266.9 avail Mem

        PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
        388 root      20   0  154352  71100  17948 S   0.0   1.8   0:06.54 python3.10
        177 root      20   0 1467084  39328  18196 S   0.0   1.0   0:01.20 snapd
        443 root      20   0   43172  37444  10048 S   0.0   0.9   0:02.96 python3
        207 root      20   0  107200  21316  12800 S   0.0   0.5   0:00.36 unattended-upgr
        174 root      20   0   30100  19156  10360 S   0.0   0.5   0:00.34 networkd-dispat
        43 root      19  -1   39532  14464  13492 S   0.0   0.4   0:00.31 systemd-journal
        129 systemd+  20   0   25528  12624   8428 S   0.0   0.3   0:00.50 systemd-resolve
          1 root      20   0  165840  11020   8084 S   0.0   0.3   0:01.45 systemd
        429 masami    20   0   16928   8744   7400 S   0.0   0.2   0:00.26 systemd
        399 masami    20   0  157724   7904   5888 S   0.0   0.2   0:01.49 fish
        435 masami    20   0  157556   7252   5620 S   0.0   0.2   0:00.14 fish
        178 root      20   0   15320   7220   6276 S   0.0   0.2   0:00.23 systemd-logind
        67 root      20   0   21952   5784   4408 S   0.0   0.1   0:00.36 systemd-udevd
        175 syslog    20   0  222400   5288   4464 S   0.0   0.1   0:00.04 rsyslogd
        400 root      20   0    7520   4724   3812 S   0.0   0.1   0:00.04 login
        150 message+  20   0    8616   4524   3872 S   0.0   0.1   0:00.10 dbus-daemon
        505 masami    20   0    7792   3684   3092 R   0.0   0.1   0:00.01 top
        ```

      - 飽和度:vmstat で swpd/si/so を見る。通常 0。
        ```
        masami@DESKTOP-L18OTEK /m/c/U/user> vmstat
        procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
        r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
        0  0      0 2959188  35796 534740    0    0    36    13   10   31  0  0 99  0  0
        ```
      - エラー:各社のツールを使用する？

    - メモリリソースのワークロードの特性の把握チェックリスト。個々の指標の取得方法を入れること。まず OS が提供する既存の可観測性ツールを使うようにしなさい。

      解答)

      - システム全体での物理/仮想メモリの使用率：  
        物理メモリ使用率＝ MemTotal-MemAvailable/MemTotal  
        仮想メモリ使用量＝ SwapTotal

      ```
      masami@DESKTOP-L18OTEK /m/c/U/user [1]> cat /proc/meminfo
      MemTotal:        4014868 kB
      MemFree:         3113680 kB
      MemAvailable:    3350992 kB
      Buffers:           44704 kB
      Cached:           380516 kB
      SwapCached:            0 kB
      Active:           138044 kB
      Inactive:         450540 kB
      Active(anon):       2516 kB
      Inactive(anon):   163948 kB
      Active(file):     135528 kB
      Inactive(file):   286592 kB
      Unevictable:           0 kB
      Mlocked:               0 kB
      SwapTotal:             0 kB
      SwapFree:              0 kB
      Dirty:                16 kB
      Writeback:             0 kB
      AnonPages:        153580 kB
      Mapped:           118072 kB
      Shmem:              3100 kB
      KReclaimable:      30452 kB
      Slab:              68088 kB
      SReclaimable:      30452 kB
      SUnreclaim:        37636 kB
      KernelStack:        2768 kB
      PageTables:         3412 kB
      NFS_Unstable:          0 kB
      Bounce:                0 kB
      WritebackTmp:          0 kB
      CommitLimit:     2007432 kB
      Committed_AS:     651020 kB
      VmallocTotal:   34359738367 kB
      VmallocUsed:       23164 kB
      VmallocChunk:          0 kB
      Percpu:             1760 kB
      AnonHugePages:     51200 kB
      ShmemHugePages:        0 kB
      ShmemPmdMapped:        0 kB
      FileHugePages:         0 kB
      FilePmdMapped:         0 kB
      HugePages_Total:       0
      HugePages_Free:        0
      HugePages_Rsvd:        0
      HugePages_Surp:        0
      Hugepagesize:       2048 kB
      Hugetlb:               0 kB
      DirectMap4k:       54272 kB
      DirectMap2M:     4139008 kB
      DirectMap1G:     8388608 kB
      ```

      - 飽和度：ページング(vmstat の si, so)、スワッピング(vmstat の swpd)、OOM キラーによる強制終了(cat /var/log/messages)
      - カーネル(cat /proc/meminfo の slab)とファイルシステムキャッシュ(sar -r の kbcached)のメモリ使用状況

      - プロセスごとの物理/仮想メモリの使用状況(ps aux の RSS が物理メモリ、VSZ が仮想メモリ)

      - メモリリソースコントロールがある場合はその設定状況  
        →wslconfig で 4G までになっている

  * 5. 以下の作業をしなさい

    - アプリケーションを選び、メモリアロケーションに至るコードパスの概要を説明しなさい  
      解答)  
      Linux の実機入手後

    - 次の Linux のスクリーンショットだけから見えるメモリアクティビティを説明しなさい  
      解答)  
      ディスクへの書き込み増加により、仮想メモリとして使用されているファイルシステムキャッシュがスワップアウトしている。また、ディスクの読み書き処理が詰まって、やや遅延が生じている状況。

  * 6. (オプション)カーネルの NUMA メモリ局所性ポリシーが実際にどの程度機能しているか示す指標を見つけなさい。指標のテストのために、メモリの局所性に優れていることが分かっているワークロードを開発しなさい

## ファイルシステム
* 1. ファイルシステムの用語についての以下の問いに答えなさい
  * 論理I/Oと物理I/Oの違いは何か。  
    解答)  
  * ランダムI/OとシーケンシャルI/Oの違いは何か。  
    解答)  
  * Direct I/Oとは何か。  
    解答)  
  * ノンブロッキングI/Oとは何か。  
    解答)  
  * ワーキングセットサイズとは何か。  
    解答)  
* 2. コンセプトについての以下の問いに答えなさい
  * VFSの役割は何か  
    解答)  
  * ファイルシステムレイテンシについて、特にどこでそれを計測できるかについて説明しなさい  
    解答)  
  * プリフェッチ（先読み）の目的は何か。  
    解答)  
  * DirectI/Oの目的は何か。  
    解答)  
* 3.　以下の少し難しい問いに答えなさい。
  * O_SYNCではなくfsync(2)を使うメリットを説明しなさい  
    解答)  
  * read(2)/write(2)との比較でmmap(2)の利点、欠点を説明しなさい  
    解答)  
  * 論理I/Oが物理I/Oになるとサイズが大きくなるのはどういうときかを説明しなさい  
    解答)  
  * 論理I/Oが物理I/Oになるとサイズが小さくなるのはどういうときかを説明しなさい  
    解答)  
  * ファイルシステムのCOWがパフォーマンスを向上させる仕組みを説明しなさい。  
    解答)  
* 4. あなたの環境のために次のものを作りなさい  
    解答)  
  * ファイルシステムキャッシュをチューニングするためのチェックリスト。存在するファイルシステムキャッシュをリストアップし、現在のサイズ、使用状況、ヒット率をチェックする方法をまとめること。  
    解答)  
  * ファイルシステムを操作するワークロードの特性の把握チェックリスト。個々の詳細情報の取得方法を入れること。まずOSが提供する既存の可観測性ツールを使うようにしなさい。  
    解答)  
* 5. 以下の作業をしなさい
  * アプリケーションを選び、ファイルシステムオペレーションのレイテンシの平均だけでなく、完全な分布を示すこと。
    * ファイルシステムオペレーションのレイテンシの平均だけでなく、完全な分布を示すこと。  
    解答)  
    * 個々のアプリケーションスレッドがファイルシステムオペレーションのために費やす時間の秒未満の部分を明らかにすること。  
    解答)  
  * マイクロベンチマークツールを使って、ファイルシステムキャッシュのサイズを実験的に調べなさい。使ったツールを選んだ理由を説明すること。また、ワーキングセットがキャッシングできなくなったときのパフォーマンス劣化を示しなさい（何らかの指標を使って）  
    解答)  
* 6. (オプション、高度)ファイルシステムに対する同期書き込みと非同期書き込みを計測する可観測性ツールを開発しなさい。頻度とレイテンシを表示し、発行したプロセスIDを突き止められるようにすること。また、ワークロード特性の把握にてきしたものにすること。  
    解答)  
* 7. (オプション、高度)間接的で大きくされたファイルシステムI/O、つまりアプリケーションが直接発行しないのに追加されたバイトとI/Oの統計を表示するツールを開発しなさい。ツールは、追加されたI/Oをタイプ別に分類し、理由を説明できなければならない。   
    解答)  