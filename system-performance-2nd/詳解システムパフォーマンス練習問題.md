## メソドロジ

- 1. パフォーマンスの基本用語についての以下の問いに答えなさい

  - IOPS とは何か  
    (答)秒あたりの入出力回数

  * 使用率とは何か  
    (答)リソースがどの程度の割合使用されているかを表した指標
  * 飽和とは何か  
    (答)リソースで即時処理できずにキューイングされた処理
  * レイテンシとは何か  
    (答)目的の処理が実行されるまでの時間
  * マイクロベンチマーキングとは何か  
    (答)特定処理の処理速度を測定する手段

- 2. あなたの環境で使うメソドロジを５つ選びなさい。実践する順序で並べ、個々のメソドロジを選んだ理由を説明しなさい
  - 1. 問題の記述  
       理由)  
       スタンドアローンの組み込みソフトを提供しているため、リモートでのログ等の確認が出来ない。  
       まずは、電話での状況確認になる。
  - 2. 科学的メソッド  
       理由)  
       電話超しの問診で特定できない場合は、ログを送ってもらう。  
       ログから遅くなっている箇所はある程度絞れるのと、リソースの状況もある程度掴めるようになるので仮説が立てられる。
  - 3. USE メソッド  
       理由)  
        これまでの経験に基づいた分析で原因が分からなかった場合は、
       手続きに沿った定型の診断を行う。USE メソッドは手早く出来る。
  - 4. ドリルダウン分析  
       理由)  
       定型の簡易診断で原因が掴めない場合は、高次から掘り下げを繰り返し、原因特定を行う
  - 5. パフォーマンスマントラ  
       理由)  
        原因が特定できたらパフォーマンスマントラに沿って対策を検討・実施する

* 3. 唯一のパフォーマンス指標として平均レイテンシを使ったときの問題点を簡潔に説明しなさい、99 パーセンタイルを含めれば、その問題は解決できるか  
     解答)  
     問題点は統計値として平均を採用している点。パフォーマンスにばらつきがある場合は、悪い時のパフォーマンスは平均によりほとんど隠される可能性が高い。  
     また、99 パーセントタイルは単峰分布を対象としたものであるが、多くの場合、システムパフォーマンスは 2 峰以上の分布であるため、表現として適していない場合がある。

## オペレーティングシステム

- 1. OS 用語について以下の問いに応えなさい
  - プロセス、スレッド、タスクの違いは何か
    解答)  
    プロセスはプログラムの実行環境。スレッドはスケジューリング可能な実行コンテキストであり、プロセスは複数のスレッドを持ちうる。タスクは処理の実行単位である。
  - モードスイッチとコンテキストスイッチとは何か  
    解答)  
    モードスイッチはカーネルモードとユーザーモードを切り替えるスイッチ。コンテキストスイッチはスレッドやプロセスを切り替えるスイッチ
  - ページングとスワッピングの違いは何か  
    解答)  
    ページングは仮想メモリのデータを物理メモリに読み書きすること。スワッピングはメモリとディスクのデータを交換し、実メモリより多くのデータを透過的に扱う。
  - I/O バウンドワークロードと CPU バウンドワークロードの違いは何か  
    解答)  
    I/O バウンドワークロードは CPU にほとんど負荷をかけないが、CPU バウンドワークロードは CPU への負担が大きい。
- 2. コンセプトについて以下の問いに答えなさい

  - カーネルの役割を説明しなさい  
    解答)
    カーネルは OS の中核となる機能を有する。
  - システムコールの役割を説明しなさい  
    解答)  
    カーネルモードで動く処理のインターフェース提供する
  - VFS の役割と I/O スタック内での位置を説明しなさい  
    解答)  
    ファイルシステムを抽象化する役割で、ファイルシステムの上層に位置する

- 3. 難易度の高い以下の問いに答えなさい

  - スレッドが CPU を手放す理由を列挙しなさい  
    解答)
    - 割込み処理を可能にするため
    * 消費電力の浪費を防ぐため
    * 非同期処理を可能にするため
    * モードスイッチを可能にするため
  - 仮想メモリとデマンドページングの利点を説明しなさい  
    解答)  
    仮想メモリにより実メモリより多くのデータを取り扱える  
    仮想メモリへの読み書きは時間が掛かるため、デマンドページングにより実際に必要になったタイミングで最小限のページのみを実メモリにロードして、最小限のコストでデータを読み書き可能とする。

## 可観測性ツール

- 1. 静的パフォーマンスツールの例を挙げなさい  
     解答)  
     df, dmesg, sysctl
- 2. プロファイリングとは何か  
     解答)  
     分析手法。測定し、問題点を検出・特定するために使用する。
- 3. プロファイラが 100Hz ではなく 99Hz を使うのはなぜか  
     解答)  
     ターゲットのサンプリングと歩調が合わないようにするため。  
     計測値がぶれやすくなる。
- 4. トレーシングとは何か  
     解答)  
     処理やデータの流れを追跡すること
- 5. 静的インストルメンテーションとは何か  
     解答)  
     ハードコードされたトレーシングポイント
- 6. 動的インストルメンテーションが重要な理由を説明しなさい  
     解答)  
     本番稼働しているカーネルから静的インストール面テーションでは取り出せない任意の情報を取り出せる。問題の観察をするための最後の手段として重要。
- 7. トレースポイントと kprobe の違いは何か  
     解答)  
     トレースポイントとは静的インストルメンテーションのイベントソース  
     kprobe は動的インストルメンテーションのイベントソース
- 8. 以下の作業で予想される CPU のオーバーヘッド(低いか普通か高いか)を説明しなさい

  - ディスクの IOPS カウンタ(iostat(1)で見られるもの)  
    解答)  
    オーバーヘッドは低い。カーネルがデフォルトで有効にしているため。
  - トレーシングポイントが kprobe を使ったディスク I/O ごとのトレーシング  
    解答)  
    kretprobe を使用することになるのでオーバーヘッドは低くないが、ディスク I/O のコストと比較すると普通程度と予想。
  - トレーシングポイントが kprobe を使ったコンテキストスイッチごとのトレーシング  
     解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。
  - トレーシングポイントが kprobe を使ったプロセスの起動(execve(2))ごとのトレーシング  
    解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。
  - uprobe を使った libc_malloc()が呼び出しごとのトレーシング  
    解答)  
    関数開始ポイントのみのトーレシングポイントになるのでオーバーヘッドは低い。

- 9. パフォーマンス分析で PMC に価値がある理由を説明しなさい  
     解答)  
     PMC でのみ得られるプロセッサのプロファイル情報から、CPU の使い方を最適化できる。

- 10. 可観測性ツールが与えられたとき、どうすればそれが使っているインストルメンテーションを明らかにできるか説明しなさい  
      解答)  
      ツールが提供する統計量と一致する情報を提供する標準的なツールを探し出し、ソースコードを辿る。

## アプリケーション

- 1. 用語についての以下の問いに答えなさい

  - キャッシュとは何か  
    解答)  
    1 度アクセスした情報を高速にアクセスできる位置に一時的に保存しておく方法
  - リングバッファとは何か  
    解答)  
    ローテーションでメモリを使用するバッファ  
    メモリサイズが固定なので、メモリ確保のコストがない

  - スピンロックとは何か  
    解答)  
    複数のスレッドやプロセスが共有リソースへのアクセスを制御するために使用する。リソースが他のスレッドやプロセスによって利用可能になるのを待つ代わりに、ロック解除されるまで継続的に試行し続ける。
  - アダプティブミューテックスロックとは何か  
    解答)
    複数のスレッドが共有リソースへのアクセスを制御するために使用する。待機時間が短い場合にはスピンロックのように動作し、長い場合はスレッドをスリープさせて、CPU の無駄遣いを防ぐ。
  - 並行実行と並列処理の違いは何か  
     解答)
    　　並行実行は複数タスクが on-CPU されるとは限らないが、並列処理は複数タスクが on-CPU になる
  - CPU アフィニティとは何か  
    解答)  
    特定のプロセスまたはスレッドが実行される CPU コアを制御する概念。リソース制限やパフォーマンス向上を目的としている。

- 2. コンセプトについての以下の問いに答えなさい

  - 大きな I/O サイズを使うことの一般的な長所・短所は何か  
    解答)  
    長所：I/O サイズが大きくなることで I/O の頻度が減り、CPU の待ち時間が減る。一方で、余計なメモリを確保し、リソースを無駄遣いする場合もある。
  - ロックのハッシュテーブルは何のために使われているか  
    解答)  
    1 個のロックリソースを共有することによるロック競合を回避しつつ、対象リソース毎にロックリソースを用意した場合のロック制御の CPU 負荷の増大化を回避するための使用。

  - コンパイル言語、インタープリタ言語、仮想マシンを使う言語の実行時の一般的なパフォーマンス特性を説明しなさい  
    解答)  
    コンパイル言語は CPU の実行可能なバイナリファイルが生成されるため、パフォーマンスは良い傾向にある。インタープリタ言語はプログラム実行時に動的に機械語に変換するため、パフォーマンスが低い傾向にある。仮想マシンはコンパイルとインタープリタの両方をサポートしている。仮想マシン上で動作するためコンパイルをしたとしても、コンパイル言語よりはパフォーマンスは落ちる。

  - ガベージコレクションの役割とパフォーマンスに与える影響について答えなさい  
    解答)  
    不要になったマネージドオブジェクトの使用メモリを自動的に解法し、大部分のメモリ管理を自動管理する。ガベージコレクションは比較的コストの大きい処理であるため、CPU 負荷が高く、他の処理を遅くする可能性がある。

* 3. アプリケーションを選び、以下の基本的な問いに答えなさい  
     選択したアプリケーション:zopfli  
     https://github.com/google/zopfli/blob/master/README.zopflipng

  - そのアプリケーションの役割は何か  
    解答)  
    png の圧縮

  - そのアプリケーションは別々のオペレーションとして何をしているか  
    解答)  
    png のロード

  - そのアプリケーションはユーザーモードとカーネルモードのどちらで実行されるか  
    解答)  
    ユーザーモード

  - そのアプリケーションはどのように構成されているか。パフォーマンスに関して、どのようなオプションがあるか  
    解答)  
    イテレーションを指定して、イテレーション回数のを枝切りが可能

  - そのアプリケーションはどのようなパフォーマンス指標を提供しているか  
    解答)  
    圧縮率

  - そのアプリケーションはどのようなログを作っているか。ログにパフォーマンス指標は含まれているか  
    解答)  
    ログはなく、標準出力のみ。

  - そのアプリケーションの最新バージョンはパフォーマンス問題を解決しているか  
    解答)  
    はい。ただし、もうメンテナンスは数年おこなわれていない。

  - そのアプリケーションに既知のパフォーマンスバグはあるか  
    解答)  
    圧縮率が増えた場合に、レポートの圧縮率がアンダーフローを起こすバグがある
  - そのアプリケーションにコミュニティはあるか。パフォーマンスコミュニティはどうか  
    解答)  
    Github がコミュニティになっている、パフォーマンスコミュニティの存在は認識していない。

  - そのアプリケーションについての本はあるか。パフォーマンスについての本はどうか  
    解答)  
    本はない

  - そのアプリケーションのパフォーマンスについて有名なエキスパートはいるか。いるなら誰か  
    解答)  
    いない

* 4. 負荷のかかっているアプリケーションを選び、以下の作業をしなさい（多くのものは動的トレーシングを必要とする)  
     選択したアプリケーション:zopfli

  - 計測を行う前に、そのアプリケーションが CPU バウンドか I/O バウンドか予想しなさい。また、その理由を説明しなさい。  
    解答)  
    CPU バウンド。zopfli でサポートしている deflate 圧縮は通常 CPU コストの高さから試行回数を 1 回で打ち切るようにしているが、zopfli は圧縮試行を何回も行うため。

  - CPU バウンドか I/O バウンドかを可観測性ツールで明らかにしなさい  
    解答)  
    top コマンドで確認したところ、zopflipng プロセスの 動作中の大部分の時間において CPU 使用率が 100%になっている

    ```
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    590 masami    20   0   10288   7764   3624 R  99.7   0.2   0:13.43 zopflipng
    441 root      20   0  967556  84808  26316 S   0.3   2.1   0:30.21 python3.10
    447 root      20   0   43180  37628  10156 S   0.3   0.9   0:12.75 python3
    588 masami    20   0    7796   3704   3108 R   0.3   0.1   0:00.10 top
    ・・・
    ```

    perf コマンドで確認すると、1.90 insn per cycle なので、2core をほとんど CPU 命令に使い切っている状況

    ```
    masami@DESKTOP-L18OTEK /m/c/U/user [255]> sudo perf stat -a -- sleep 10
    [sudo] password for masami:

    Performance counter stats for 'system wide':

          40020.11 msec cpu-clock                 #    4.000 CPUs utilized
               683      context-switches          #   17.066 /sec
                14      cpu-migrations            #    0.350 /sec
              3960      page-faults               #   98.950 /sec
       16216576252      cycles                    #    0.405 GHz
       30786259882      instructions              #    1.90  insn per cycle
        7054228214      branches                  #  176.267 M/sec
         169069741      branch-misses             #    2.40% of all branches

      10.004642769 seconds time elapsed
    ```

  - そのアプリケーションの CPU フレームグラフを作りなさい。この課題では、シンボルとスタックトレースの修復が必要になる場合がある。もっともホットな CPU コードパスは何か  
     解答)  
     プリインストールされている zopfli 実行中のフレームグラフを作ったところ、シンボルが Unknown で追跡が難しい状況

    ```sh
    git clone https://github.com/brendangregg/FlameGraph
    cd FlameGraph
    perf record -F 99 -a -g -- sleep 60
    perf script | ./stackcollapse-perf.pl > out.perf-folded
    ./flamegraph.pl out.perf-folded > perf-kernel.svg
    ```

    ![1](https://github.com/pea-sys/linux-experiments/assets/49807271/97a64941-885b-4196-9442-b241dc07fd64)  
    ネイティブなプログラムのシンボルを追跡するためには再コンパイルが必要？
    次にあるように、Zopfli のコンパイルは難しい状況。
    https://github.com/google/zopfli/issues/143

  - そのアプリケーションの off-CPU フレームグラフを作りなさい。要求の処理中にブロックする時間が最も長いイベントは何か(アイドルスタックは無視する)  
    解答)

  * 実行する I/O のサイズ(例えば、ファイルシステムの読み書き、ネットワークの送受信)の特性を説明しなさい  
    解答)

  * そのアプリケーションはキャッシュを持っているか。あるなら、サイズとヒット率を明らかにしなさい  
    解答)

  * そのアプリケーションを実行するオペレーションのレイテンシ(応答時間)を計測しなさい。平均、最小値、最大値、全体の分布を示しなさい  
    解答)

  * オペレーションのドリルダウン分析を行い、レイテンシの主要部がどこに発生しているかを解析しなさい  
    解答)

  * そのアプリケーションのワークロード特性を明らかにしなさい(特に誰がと何を)  
    解答)

  * 静的パフォーマンスチューニングチェックリストをすべてチェックしなさい  
    解答)

  * そのアプリケーションは並列実行されるか。同期プリミティブの使われ方を調べなさい  
    解答)

* 5. (高度)複数のスレッド状態分析欄を持ち、それぞれで使った時間を表示する tsastat(8)という Linux 用のツールを開発しなさい、このツールは、pidstat(1)と同じように動作し、変化の過程を出力できるものとする  
     解答)
